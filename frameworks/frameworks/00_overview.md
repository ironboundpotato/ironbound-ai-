# IRONBOUND-AI Frameworks Overview (v1.1)
Part of the IRONBOUND-AI Operator System  
Version 1.1 • 2026  
Author: Kevin Gilbert (TB)

## Purpose of This Document

This file provides a **high-level overview** of the framework layer inside IRONBOUND-AI.  
Where *protocols* govern execution, frameworks define the **conceptual architecture** that guides all AI reasoning, role behavior, and workflow control.

Frameworks supply the **why** behind the **how**.

They define:
- the philosophical foundation  
- the system logic  
- the conceptual mechanics  
- the stabilization principles  
- the constraints that anchor every model  

This document maps the framework territory and explains how each framework interacts with the operational layer.

---

# Section 1 — What Frameworks Are

Frameworks are the **deep structures** of IRONBOUND-AI.

They answer:
- What is drift?  
- Why does drift occur?  
- How must roles operate?  
- Why do constraints exist?  
- What is the system trying to preserve?  

Frameworks provide:
- conceptual definitions  
- governing laws  
- stabilization logic  
- behavioral boundaries  
- interpretive discipline  

Frameworks = the **philosophical engine**.

Protocols   = the **mechanical engine**.  
Roles       = the **biomechanics**.  
Operator    = the **governing intelligence**.

---

# Section 2 — The Four Core Framework Families

IRONBOUND-AI uses four Framework Families:

## **1. Foundational Laws**  
These define the **universal rules of generative stability**, including:
- why models drift  
- how structure collapses  
- how meaning distorts  
- why constraints must exist  
- what makes operator authority absolute  

The Foundational Laws are the spine of the entire system.

---

## **2. Constraint Frameworks**

These define the constraints that bind AI behavior:
- The Seven Immutable Constraints  
- Density and Structure Laws  
- Role–Constraint Alignment  
- Boundary Enforcement Logic  

Constraints keep models from:
- expanding  
- improvising  
- drifting  
- merging roles  
- violating structure  

Constraints = behavioral physics.

---

## **3. Role Frameworks**

These define:
- what each role is  
- what each role must do  
- what each role must NOT do  
- how roles interact  
- why separation is mandatory  

Roles enable deterministic multi-model workflows by preventing:
- contamination  
- overreach  
- tone drift  
- intent drift  
- structure drift  

Roles = controlled specialization.

---

## **4. Drift Architecture Frameworks**

These define the **Six Demons**:
1. Role Drift  
2. Tone Drift  
3. Format Drift  
4. Intent Drift  
5. Scope Drift  
6. Confidence Drift  

The Drift Architecture explains:
- how drift emerges  
- how drift propagates  
- how drift hides  
- how drift is measured  
- how drift is interrupted  

This is the diagnostic engine behind all protocols.

---

# Section 3 — How Frameworks Interact with Protocols

Frameworks define the **logic**.  
Protocols define the **execution rules**.

| Layer | Purpose |
|------|---------|
| **Frameworks** | Define the conceptual laws that govern behavior. |
| **Protocols** | Convert those laws into step-by-step operations. |
| **Roles** | Execute those steps without overlap. |
| **Operator** | Controls sequence, density, constraints, and intent. |

Frameworks → Protocols → Roles → Output.

This layered dependency ensures:
- absolute operator control  
- zero drift  
- predictable reasoning  
- repeatable workflows  
- stable document generation  
- safe multi-model orchestration  

---

# Section 4 — Why Frameworks Exist

Frameworks prevent:
- meaning distortion  
- hidden drift  
- overgeneration  
- undergeneration  
- hallucinated structure  
- tone contamination  
- role merging  
- scope inflation  
- confidence overreach  

Frameworks give the operator:
- predictable outcomes  
- consistent density  
- stable structure  
- repeatability  
- constraint integrity  
- controllable complexity  

Without frameworks, protocols collapse.  
Without protocols, roles collapse.  
Without roles, drift wins.

Frameworks are the **deep rules of the machine.**

---

# Section 5 — When to Use Frameworks vs Protocols

Use **frameworks** when:
- defining conceptual systems  
- designing new workflows  
- diagnosing drift sources  
- building high-level structures  
- aligning roles to rules  

Use **protocols** when:
- running workflows  
- performing revisions  
- enforcing structure  
- preventing or correcting drift  
- following step-based processes  

Frameworks = blueprint.  
Protocols = operating procedure.

---

# Section 6 — The Operator’s Responsibilities Within Frameworks

The operator must:
- set density  
- set constraints  
- define roles  
- maintain structure  
- enforce boundaries  
- interrupt drift  
- reissue macros  
- control sequence  
- preserve intent  

Frameworks empower the operator.  
Protocols obey the operator.  
Roles serve the operator.

IRONBOUND-AI is operator-sovereign by design.

---

# Section 7 — Framework Family Index (What Comes Next)

The remaining files in this directory expand into:

### `01_foundational_laws.md`
The non-negotiable laws of stability and generative reasoning.

### `02_constraint_principles.md`
The conceptual basis for the Seven Immutable Constraints and related enforcement physics.

### `03_role_architecture.md`
The philosophical definition and boundaries of each role.

### `04_drift_architecture.md`
The full Six-Demon Drift Model and its conceptual mechanics.

### `05_interaction_models.md`
How frameworks, protocols, and roles synchronize during multi-model workflows.

---

End of file.